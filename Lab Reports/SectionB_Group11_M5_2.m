% Shelley Wei, Cindy Ning, Nikhil Misra, Edward Liu
% ENGR 130
% Module 5, Group 11
% Started 11/7/23
% Finished 11/7/23
% Due 11/13/23

% 2. Collect and process data from the oscilloscope
clear; clc; close all;

heartbeat = readmatrix("M5_Heartbeat.csv");

time = heartbeat(3:end, 1);
voltage = heartbeat(3:end, 2);

[f1, y1] = ENGR130_Fourier(time, voltage);

% remove the first data point from the vectors (frequency of 0, peak voltage)
f1 = f1(2:end);
y1 = y1(2:end);

stem(f1, y1);
xlim([0,2]);
xlabel("Frequency");
ylabel("Amplitude");
title("Heartbeat");

% 3. Analyze the signal in the frequency domain
freq = getComponentParams(f1, y1, 0.2);

% sanity check
% freqMajor = getComposite(freq(:, 1), freq(:, 2), time);
% plot(time, freqMajor);

fprintf("The heartrate is %.2f beats per minute.\n", freq(1, 1)*60);

%% Functions
function  y = getSinusoid(f,A,t)
    % This function generates the y-value of a given sine function & time domain
    % Call Format: getSinusoid(f,A,t)
    % Input: 
    %    f: frequency
    %    A: amplitude
    %    t: time vector
    % Output: 
    %    y: the y-values of the sinusoid
    y = A*sin(2*pi*f.*t);
end

function composite = getComposite(f, A, t)
    % Generates the y-value for a given composite (sum of sine functions)
    % Call Format: getComposite(f,A,t)
    % Inputs
    %    f: frequency vector
    %    A: amplitude vector
    %    t: time vector
    % Output
    %    composite: the y-values of the composite

    % throw an error if the frequency and amplitude vectors are different
    % lengths since they then can't be analyzed together as there is
    % probably missing data
    if (length(f) ~= length(A))
        error("The length of the frequency and amplitude vector is different");
    end
          
    composite = 0; % initialize composite vector of different sin functions

    for i = 1:length(f)
       composite = composite + getSinusoid(f(i), A(i), t); % add sin functions to the composite vector
    end
end

function m = getComponentParams(f, Y, thresh)
    % This function return a 2-column matrix where the first column contains the 
    % major frequencies and the second column contains the corresponding amplitudes
    % Call format: getComponentParams(frequcency, amplitude, threshold)
    % Inputs
    %   f: the frequency vector for the signal
    %   Y: the amplitude vector for the signal, thresh=threshold for the amplitude
    % Output
    %   m: a 2-column matrix where the first column contains the major frequencies and the second column contains the corresponding amplitudes
    m = [f(Y>thresh); Y(Y>thresh)]'; % use logical indexing to find the corresponding indices where the amplitude is greater than the threshold for the frequency and amplitude vectors
end

function [f, Y] = ENGR130_Fourier(t, signal)
    % ENGR130_Fourier uses Matlab's fft() function together with additional
    % post-processing steps to convert from time to frequency domain for an
    % input signal.
    %
    % Syntax:
    %   [f, Y] = ENGR130_Fourier(t, signal) 
    %
    % Inputs:
    %    t      - A time vector with uniform stepsize (likely generated by MATLAB
    %             or collected by the oscilloscope
    %    signal - The corresponding voltage values for each point in t.
    %             This array must be the same size as t_in.
    %
    % Outputs:
    %    f     - A frequency vector corresponding to the fft of signal
    %    Y     - The amplitude contributions at each frequency f.
    %
    % Example Usage:
    %   [frequency, Amplitude] = ENGR130_Fourier(time, Voltage_collected)
    
    % Nov 2020; Last revision: Rhoads 10-28-2022
    %
    %------------- BEGIN CODE --------------
    
    % Change column vectors to row vectors
    [rows, ~] = size(signal);
    if rows > 1
        signal = signal';
        t = t';
    end
    
    % Look for poor importing (Titles, names, not numbers...)
    t_new = t(~isnan(t));
    
    shift = length(t) - length(t_new);
    t = t_new - min(t_new);
    signal = signal(1:end - shift);
    
    % define dt for given time step
    dt = t(2) - t(1);
    
    % create time vector for given time
    xq = 0:dt:max(t);
    
    % Have to get unique points out of the way,
    %    although there should be none.
    [time_u, index] = unique(t); 
    vq = interp1(time_u, signal(index), xq);
    
    % If the data doesn't start right away, there are issues
    % Specifically, NaN shows up and clutters the DC Offset
    signal = vq(~isnan(vq));
    
    % Starting to do the Fourier transform
    N = length(signal);
    
    % define sampling frequency, Hz
    fs = 1/dt;
    
    % We need an even number of samples, so just chop off the excess
    if rem(N, 2) ~= 0
        signal = signal(1:end-1);
    end
    
    % total number of samples
    N = length(signal);
    
    % discrete Fourier transform
    Y = fft(signal);
    
    % create the frequency variable
    f = fs/N * (0:N/2);
    
    % shorten DFT to only half of the values (positive Frequencies)
    Y = Y(1:N/2+1);
    
    % Normalize the Fourier transform, take absolute magnitude
    Y = abs(Y)/N;
    
    % correct normalization b/c only using half the freqeuncies.
    Y(2:end) = 2 * Y(2:end);
end