% Shelley Wei, Cindy Ning, Nikhil Misra, Edward Liu
% ENGR 130
% Module 5, Group 11
% Started 10/31/23
% Finished 11/2/23
% Due 11/6/23

% LAB 1
clear; clc; close all;

% Sinusoidal signal generation
% declaring dt and the time vector
dt = 1/1024;

time = linspace(0, 1-dt, 1024);
% create an equally spaced time vercor with intervals of 1/1024

numel(time);
% check the time vercor has 1024 values

% LAB 2
amp = [1 20 5 3 17 1.5];
freq = [12 17 20 5 15 5];
% given amplitude and corresponding frequency for the composite signal

% get the sum of y-values from the 6 components with different amplitudes and frequencies
y_comp = getComposite(freq, amp, time);

% plot the composite signal (sin graphs stacked on each other)
figure(1);
plot(time, y_comp, "r");
% labels
title("Composite Signal Graph");
xlabel("Time (sec)");
ylabel("Midterm Grade for ENGR130 (unitless)"); % ~ Dr. Harper

% 3. Analyze your signal via Fourier transform
[f_comp, Y_comp] = ENGR130_Fourier(time, y_comp);
% calculate the frequency and amplitude using the given fourier function
figure(2);
stem(f_comp,Y_comp);
xlim([0,25])%limit x axis since there's nothing useful beyond 0.25
% labels
xlabel('Frequency');
ylabel('Amplitude');
title('Fourier Transform of the Composite Signal');

% 4. Deconstruct a mystery signal
load("mystery_signal.mat");%load the data that we need to analyze

[fMystery, yMystery] = ENGR130_Fourier(time, mystery);
% calculate the frequency and amplitude using the given fourier function

figure(3)
subplot(2, 1, 1);
% create two subplots, and plot on the first subplot the mystery signal
plot(time, mystery);
% labels
xlabel('Time (sec)');
ylabel('Mystery Signal');
title('Mystery Signal Sinusoid');

subplot(2, 1, 2)
% Plot on the second subplot the fourier transform of the mystery signal
stem(fMystery, yMystery);
xlim([0, 410])
% labels
xlabel('Frequency');
ylabel('Amplitude');
title('Fourier Transform of the Mystery Signal');

% find the components of the mystery signal with amplitude greater than 4
matrix = getComponentParams(fMystery, yMystery, 4);

% eliminate the components with amplitude greater than 4 from mystery signal
mysteryNoise = mystery - getComposite(matrix(:, 1), matrix(:, 2), time);

% replot the mystery signal with components greater than 4 eliminated
figure(4);
plot(time,mysteryNoise);
% labels
ylabel('Noise Extracted from the Mystery Signal');
xlabel('Time (sec)');
title('Noise of the Mystery Signal');

% Functions
function  y = getSinusoid(f,A,t)
    % This function generates the y-value of a given sine function & time domain
    % Call Format: getSinusoid(f,A,t)
    % Input: 
    %    f: frequency
    %    A: amplitude
    %    t: time vector
    % Output: 
    %    y: the y-values of the sinusoid
    y = A*sin(2*pi*f.*t);
end

function composite = getComposite(f,A,t)
    % Generates the y-value for a given composite (sum of sine functions)
    % Call Format: getComposite(f,A,t)
    % Inputs
    %    f: frequency vector
    %    A: amplitude vector
    %    t: time vector
    % Output
    %    composite: the y-values of the composite

    % throw an error if the frequency and amplitude vectors are different
    % lengths since they then can't be analyzed together as there is
    % probably missing data
    if (length(f) ~= length(A))
        error("The length of the frequency and amplitude vector is different");
    end
          
    composite = 0; % initialize composite vector of different sin functions

    for i = 1:length(f)
       composite = composite + getSinusoid(f(i),A(i),t); % add sin functions to the composite vector
    end
end

function m = getComponentParams(f,Y,thresh)
    % This function return a 2-column matrix where the first column contains the 
    % major frequencies and the second column contains the corresponding amplitudes
    % Call format: getComponentParams(frequcency, amplitude, threshold)
    % Inputs
    %   f: the frequency vector for the signal
    %   Y: the amplitude vector for the signal, thresh=threshold for the amplitude
    % Output
    %   m: a 2-column matrix where the first column contains the major frequencies and the second column contains the corresponding amplitudes
    m = [f(Y>thresh);Y(Y>thresh)]'; % use logical indexing to find the corresponding indices where the amplitude is greater than the threshold for the frequency and amplitude vectors
end


function [f, Y] = ENGR130_Fourier(t, signal)
    % ENGR130_Fourier uses Matlab's fft() function together with additional
    % post-processing steps to convert from time to frequency domain for an
    % input signal.
    %
    % Syntax:
    %   [f, Y] = ENGR130_Fourier(t, signal) 
    %
    % Inputs:
    %    t      - A time vector with uniform stepsize (likely generated by MATLAB
    %             or collected by the oscilloscope
    %    signal - The corresponding voltage values for each point in t.
    %             This array must be the same size as t_in.
    %
    % Outputs:
    %    f     - A frequency vector corresponding to the fft of signal
    %    Y     - The amplitude contributions at each frequency f.
    %
    % Example Usage:
    %   [frequency, Amplitude] = ENGR130_Fourier(time, Voltage_collected)
    
    % Nov 2020; Last revision: Rhoads 10-28-2022
    %
    %------------- BEGIN CODE --------------
    
    % Change column vectors to row vectors
    [rows, ~] = size(signal);
    if rows > 1
        signal = signal';
        t = t';
    end
    
    % Look for poor importing (Titles, names, not numbers...)
    t_new = t(~isnan(t));
    
    shift = length(t) - length(t_new);
    t = t_new - min(t_new);
    signal = signal(1:end - shift);
    
    % define dt for given time step
    dt = t(2) - t(1);
    
    % create time vector for given time
    xq = 0:dt:max(t);
    
    % Have to get unique points out of the way,
    %    although there should be none.
    [time_u, index] = unique(t); 
    vq = interp1(time_u, signal(index), xq);
    
    % If the data doesn't start right away, there are issues
    % Specifically, NaN shows up and clutters the DC Offset
    signal = vq(~isnan(vq));
    
    % Starting to do the Fourier transform
    N = length(signal);
    
    % define sampling frequency, Hz
    fs = 1/dt;
    
    % We need an even number of samples, so just chop off the excess
    if rem(N, 2) ~= 0
        signal = signal(1:end-1);
    end
    
    % total number of samples
    N = length(signal);
    
    % discrete Fourier transform
    Y = fft(signal);
    
    % create the frequency variable
    f = fs/N * (0:N/2);
    
    % shorten DFT to only half of the values (positive Frequencies)
    Y = Y(1:N/2+1);
    
    % Normalize the Fourier transform, take absolute magnitude
    Y = abs(Y)/N;
    
    % correct normalization b/c only using half the freqeuncies.
    Y(2:end) = 2 * Y(2:end);
end